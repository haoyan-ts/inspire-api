"""Pressure test script for Inspire Hand serial interface.

Repeatedly reads joint angles from the hand and records metrics for analysis.

Usage:
    python scripts/pressure_test_serial.py --port COM3 --baud 115200 --duration 60

Outputs a CSV file with one row per read and prints a summary at the end.
"""

from __future__ import annotations

import argparse
import csv
import signal
import sys
import time
from datetime import datetime

import numpy as np

from inspire_api.serial import InspireHandSerial


def parse_args() -> argparse.Namespace:
    p = argparse.ArgumentParser(
        description="Pressure test InspireHandSerial by repeatedly reading angles"
    )
    p.add_argument(
        "--port", type=str, default=None, help="Serial port (e.g. COM3 or /dev/ttyUSB0)"
    )
    p.add_argument(
        "--baud", type=int, default=115200, help="Baudrate (default: 115200)"
    )
    p.add_argument(
        "--duration",
        type=float,
        default=60.0,
        help="Test duration in seconds (default: 60s)",
    )
    p.add_argument(
        "--interval",
        type=float,
        default=0.03,
        help="Interval between reads in seconds (default: 30ms)",
    )
    p.add_argument(
        "--hand-id", type=int, default=1, help="Hand ID to query (default: 1)"
    )
    p.add_argument(
        "--out",
        type=str,
        default=None,
        help="Output CSV file path (default: autogenerated)",
    )
    p.add_argument(
        "--debug", action="store_true", help="Enable debug mode for the hand instance"
    )
    return p.parse_args()


class PressureTester:
    def __init__(
        self, port: str | None, baud: int, hand_id: int, interval: float, debug: bool
    ):
        self.port = port
        self.baud = baud
        self.hand_id = hand_id
        self.interval = interval
        self.debug = debug

        self.hand = InspireHandSerial(
            port=self.port or "", baudrate=self.baud, debug=self.debug
        )
        self._stop_requested = False

        # metrics
        self.records = []

    def _signal_handler(self, signum, frame):
        print("\nStop requested (signal). Finishing current iteration and exiting...")
        self._stop_requested = True

    def connect(self) -> None:
        # Best-effort connect; let the underlying class raise on failure
        self.hand.connect()

    def disconnect(self) -> None:
        try:
            self.hand.disconnect()
        except Exception:
            # ignore errors on disconnect
            pass

    def run(self, duration: float) -> None:
        signal.signal(signal.SIGINT, self._signal_handler)
        signal.signal(signal.SIGTERM, self._signal_handler)

        start_time = time.time()
        end_time = start_time + duration
        iteration = 0

        while time.time() < end_time and not self._stop_requested:
            iteration += 1
            t0 = time.time()
            timestamp = datetime.utcnow().isoformat() + "Z"

            try:
                angles = self.hand.get_angle_actual(self.hand_id)
                read_err = False
                err_msg = ""
            except Exception as e:  # keep broad to capture comm errors
                angles = np.array([], dtype=np.int32)
                read_err = True
                err_msg = str(e)

            t1 = time.time()
            elapsed_ms = (t1 - t0) * 1000.0

            # normalize angles to list of 6 ints (pad with None if missing)
            angle_list = []
            try:
                if hasattr(angles, "tolist"):
                    vals = list(map(int, np.asarray(angles).tolist()))
                else:
                    vals = list(map(int, angles))
            except Exception:
                vals = []

            for i in range(6):
                if i < len(vals):
                    angle_list.append(str(vals[i]))
                else:
                    angle_list.append("")

            rec = {
                "timestamp": timestamp,
                "iteration": iteration,
                "elapsed_ms": f"{elapsed_ms:.3f}",
                "error": "1" if read_err else "0",
                "error_msg": err_msg,
            }
            for i in range(6):
                rec[f"angle_{i}"] = angle_list[i]

            self.records.append(rec)

            # sleep respecting interval, but don't overshoot end_time
            now = time.time()
            next_time = t0 + self.interval
            sleep_time = max(0.0, min(next_time - now, end_time - now))
            if sleep_time > 0:
                time.sleep(sleep_time)

        # finished

    def save_csv(self, filepath: str) -> None:
        if not self.records:
            print("No records to save.")
            return

        fieldnames = ["timestamp", "iteration", "elapsed_ms", "error", "error_msg"] + [
            f"angle_{i}" for i in range(6)
        ]

        with open(filepath, "w", newline="", encoding="utf-8") as f:
            writer = csv.DictWriter(f, fieldnames=fieldnames)
            writer.writeheader()
            for r in self.records:
                writer.writerow(r)

    def print_summary(self) -> None:
        total = len(self.records)
        if total == 0:
            print("No reads were performed.")
            return

        failures = sum(1 for r in self.records if r.get("error") == "1")
        successes = total - failures
        times = [float(r["elapsed_ms"]) for r in self.records if r.get("elapsed_ms")]

        avg_ms = sum(times) / len(times) if times else 0.0
        min_ms = min(times) if times else 0.0
        max_ms = max(times) if times else 0.0

        print("\n--- Pressure Test Summary ---")
        print(f"Total reads: {total}")
        print(f"Successful reads: {successes}")
        print(f"Failed reads: {failures}")
        print(f"Average read time (ms): {avg_ms:.3f}")
        print(f"Min read time (ms): {min_ms:.3f}")
        print(f"Max read time (ms): {max_ms:.3f}")


def main() -> None:
    args = parse_args()

    # build output filename if not provided
    ts = datetime.utcnow().strftime("%Y%m%dT%H%M%SZ")
    out_path = args.out or f"pressure_test_{ts}.csv"

    tester = PressureTester(
        port=args.port,
        baud=args.baud,
        hand_id=args.hand_id,
        interval=args.interval,
        debug=args.debug,
    )

    try:
        print(f"Connecting to hand on port={args.port} baud={args.baud} ...")
        tester.connect()
    except Exception as e:
        print(f"Failed to connect to the hand: {e}")
        sys.exit(2)

    try:
        print(
            f"Starting pressure test for {args.duration} seconds (interval={args.interval}s) ..."
        )
        tester.run(args.duration)

        print(f"Saving results to {out_path} ...")
        tester.save_csv(out_path)

        tester.print_summary()

    finally:
        tester.disconnect()


if __name__ == "__main__":
    main()
